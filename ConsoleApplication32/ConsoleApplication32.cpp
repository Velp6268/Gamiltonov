#include <iostream>


using namespace std;

const int n = 6;
int c[n];           // номер хода, на котором посещается вершина
int path[n];        // номера посещаемых вершин
int v0 = 5;         // начальная вершина

int a[n][n] =       //матрица смежности
{
    0,1,1,1,0,0,
    1,0,0,0,1,0,
    1,0,0,1,1,0,
    1,0,1,0,1,0,
    0,1,1,1,0,0,
    0,1,1,1,0,0,
};


void printGam(void)
{
    int p;
    for (p = 0; p < n; p++)
        cout << path[p] + 1 << " ";
    cout << path[0] + 1;
    cout << endl;
}

//подпрограмма нахождения гамильтонова цикла
//k - номер прохода или количество найденных вершин пути, результат - массив path, возвращвет пр
int gamilton(int k)
{
    int v;          //индекс вершины
    int q1 = 0;     //признак нахождения пути, сначала - не найдено
    for (v = 0; v < n && !q1; v++) // обход матрицы по всем вершинам и пока не найден путь
    {
        //есть ли ребро между текущей вершиной и вершиной, найденной при предыдущем вызове
        //если граф неориентированный, то оба используемых элемента матрицы должны быть равны
        //если ориентированный, то, по идее, надо смотреть только a[path[k - 1]][v]
        if (a[v][path[k - 1]] || a[path[k - 1]][v])
        {
            if (k == n && v == v0)          //если обошли все вершины и дошли до начальной,
                q1 = 1;                     // то путь найден
            else
                if (c[v] == -1)             //формируем путь, если в вершине v еще не были
                {
                    c[v] = k;               //номер прохода
                    path[k] = v;            //занесение вершины в найденный путь
                    q1 = gamilton(k + 1);   //ищем следующую вершину
                    if (!q1) c[v] = -1;     //если путь не найден, то помечаем текущую вершину, 
                }
                else
                    continue;               //если в вершине уже были, то на анализ следующей ве
        }
    }   return q1;                          //возвращаем нашли или нет
}

int main()
{
    setlocale(LC_ALL, "rus");
    int j;
    cout << "Гамилтоновый цикл:\n ";
    for (j = 0; j < n; j++)
        c[j] = -1;                          //помечаем, что все вершины не пройдены
    path[0] = v0;                           //начинаем путь с вершины v0
    c[v0] = v0;                             // и она пройдена
    if (gamilton(1))                        //ищем путь, начиная с прохода 1
        printGam();
    else
        cout << "Нет пути\n";
}
